{"name":"murmur3","dependencies":[{"name":"bitwise","repository":"https://github.com/itsgreggreg/mint-bitwise","constraint":"0.5.0 <= v < 1.0.0"}],"components":[],"stores":[],"modules":[{"description":null,"name":"Murmur3","functions":[{"type":"Number","description":"<p>Takes a seed and a string and produces a 32 bit hash.</p>\n<p>Given the same seed and string, it will always produce the same hash.</p>\n<pre><code class=\"language-mint\">Murmur3.hash32(1234, &quot;Turn me into a hash&quot;) == 4138100590\n</code></pre>\n","name":"hash32","source":"/*\nTakes a seed and a string and produces a 32 bit hash.\n\nGiven the same seed and string, it will always produce the same hash.\n\n```mint\nMurmur3.hash32(1234, \"Turn me into a hash\") == 4138100590\n```\n*/\nfun hash32 (seed : Number, str : String) : Number {\n  str\n  |> Murmur3.Private.stringCodepointReduce(init, Murmur3.Private.hashFold)\n  |> Murmur3.Private.finalize()\n} where {\n  init =\n    {\n      shift = 0,\n      seed = seed,\n      hash = 0,\n      charsProcessed = 0\n    }\n}","arguments":[{"type":"Number","name":"seed"},{"type":"String","name":"str"}]}]},{"description":"<p>Private internals of Murmur3, do not use these.</p>\n<p>The public interface is in the <code>Murmur3</code> module.</p>\n","name":"Murmur3.Private","functions":[{"type":"Number","description":"<p>32-bit multiplication</p>\n","name":"multiplyBy","source":"/* 32-bit multiplication */\nfun multiplyBy (b : Number, a : Number) : Number {\n  w + z\n} where {\n  w =\n    Bitwise.and(a, 65535) * b\n\n  x =\n    Bitwise.zeroFillRightShift(16, a) * b\n\n  y =\n    Bitwise.and((x), 65535)\n\n  z =\n    Bitwise.leftShift(16, y)\n}","arguments":[{"type":"Number","name":"b"},{"type":"Number","name":"a"}]},{"type":"Number","description":"<p>Given a 32bit int and an int representing a number of bit positions,\nreturns the 32bit int rotated left by that number of positions.\nrotlBy : Int -&gt; Int -&gt; Int</p>\n","name":"rotlBy","source":"/*\n Given a 32bit int and an int representing a number of bit positions,\nreturns the 32bit int rotated left by that number of positions.\nrotlBy : Int -> Int -> Int\n*/\nfun rotlBy (b : Number, a : Number) : Number {\n  Bitwise.or(\n    (Bitwise.leftShift(b, a)), \n    (Bitwise.zeroFillRightShift((32 - b), a)))\n}","arguments":[{"type":"Number","name":"b"},{"type":"Number","name":"a"}]},{"type":"Murmur3.Private.HashData","description":"<p>handles each char of the input string</p>\n","name":"hashFold","source":"/* handles each char of the input string */\nfun hashFold (data : Murmur3.Private.HashData, char : Number) : Murmur3.Private.HashData {\n  case (data.shift) {\n    24 =>\n      {\n        shift = 0,\n        seed = mix(data.seed, res),\n        hash = 0,\n        charsProcessed = data.charsProcessed + 1\n      }\n\n    =>\n      {\n        shift = data.shift + 8,\n        seed = data.seed,\n        hash = res,\n        charsProcessed = data.charsProcessed + 1\n      }\n  }\n} where {\n  res =\n    char\n    |> Bitwise.and(255)\n    |> Bitwise.leftShift(data.shift)\n    |> Bitwise.or(data.hash)\n}","arguments":[{"type":"Murmur3.Private.HashData","name":"data"},{"type":"Number","name":"char"}]},{"type":"Number","description":null,"name":"mix","source":"fun mix (h1 : Number, k1 : Number) : Number {\n  res + 3864292196\n} where {\n  res =\n    k1\n    |> multiplyBy(C1)\n    |> rotlBy(15)\n    |> multiplyBy(C2)\n    |> Bitwise.xor(h1)\n    |> rotlBy(13)\n    |> multiplyBy(5)\n}","arguments":[{"type":"Number","name":"h1"},{"type":"Number","name":"k1"}]},{"type":"Number","description":null,"name":"finalize","source":"fun finalize (data : Murmur3.Private.HashData) : Number {\n  Bitwise.xor(h2, Bitwise.zeroFillRightShift(16, h2))\n  |> Bitwise.zeroFillRightShift(0)\n} where {\n  acc =\n    if (data.hash == 0) {\n      data.seed\n    } else {\n      data.hash\n      |> multiplyBy(C1)\n      |> rotlBy(15)\n      |> multiplyBy(C2)\n      |> Bitwise.xor(data.seed)\n    }\n\n  h0 =\n    Bitwise.xor(acc, data.charsProcessed)\n\n  h1 =\n    Bitwise.xor(h0, Bitwise.zeroFillRightShift(16, h0))\n    |> multiplyBy(2246822507)\n\n  h2 =\n    Bitwise.xor(h1, (Bitwise.zeroFillRightShift(13, h1)))\n    |> multiplyBy(3266489909)\n}","arguments":[{"type":"Murmur3.Private.HashData","name":"data"}]},{"type":"a","description":"<p>reduce over 32 bit codepoints of a string. handles joining surrogate pairs\ninto a single codepoint</p>\n","name":"stringCodepointReduce","source":"/*\nreduce over 32 bit codepoints of a string. handles joining surrogate pairs\n into a single codepoint\n*/\nfun stringCodepointReduce (start : a, fn : Function(a, Number, a), str : String) : a {\n  res[1]\n} where {\n  res =\n    String.split(\"\", str)\n    |> Array.reduce(\n      {0, start}, \n      (acc : Tuple(Number, b), s : String) : Tuple(Number, b) {\n        if (acc[0] == 0) {\n          case (isSurrogatePair(s)) {\n            {bool, num} =>\n              if (bool) {\n                {num, acc[1]}\n              } else {\n                {0, fn(acc[1], num)}\n              }\n          }\n        } else {\n          {0, fn(acc[1], joinSurrogatePair(acc[0], s))}\n        }\n      })\n}","arguments":[{"type":"a","name":"start"},{"type":"Function(a, Number, a)","name":"fn"},{"type":"String","name":"str"}]},{"type":"Number","description":"<p>combines 16 bit surrogate pairs into a 32 bit integer</p>\n","name":"joinSurrogatePair","source":"/* combines 16 bit surrogate pairs into a 32 bit integer */\nfun joinSurrogatePair (l : Number, r : String) : Number {\n  (l - a) * b + c - d + e\n} where {\n  a =\n    (`0xD800` as Number)\n\n  b =\n    (`0x400` as Number)\n\n  c =\n    (`#{r}.charCodeAt(0)` as Number)\n\n  d =\n    (`0xDC00` as Number)\n\n  e =\n    (`0x10000` as Number)\n}","arguments":[{"type":"Number","name":"l"},{"type":"String","name":"r"}]},{"type":"Tuple(Bool, Number)","description":"<p>determines if a character is the start of a 16 bit surrogate pair</p>\n","name":"isSurrogatePair","source":"/* determines if a character is the start of a 16 bit surrogate pair */\nfun isSurrogatePair (c : String) : Tuple(Bool, Number) {\n  if ((`0xD800` as Number) <= code && code <= (`0xDBFF` as Number)) {\n    {true, code}\n  } else {\n    {false, code}\n  }\n} where {\n  code =\n    `#{c}.charCodeAt(0)` as Number\n}","arguments":[{"type":"String","name":"c"}]}]}],"providers":[],"records":[{"description":"<p>Private data structure for computing a 32bit hash</p>\n","name":"Murmur3.Private.HashData","fields":[{"key":"shift","type":"Number","mapping":null},{"key":"seed","type":"Number","mapping":null},{"key":"hash","type":"Number","mapping":null},{"key":"charsProcessed","type":"Number","mapping":null}]}],"enums":[]}