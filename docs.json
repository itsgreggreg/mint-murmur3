{"name":"murmur3","dependencies":[{"name":"bitwise","repository":"https://github.com/itsgreggreg/mint-bitwise","constraint":"0.5.0 <= v < 1.0.0"}],"components":[],"stores":[],"modules":[{"description":null,"name":"Murmur3","functions":[{"type":"Number","description":"<p>Takes a seed and a string and produces a 32 bit hash.</p>\n<p>Given the same seed and string, it will always produce the same hash.</p>\n<p>Murmur3.hash32(1234 &quot;Turn me into a hash&quot; == 4138100590)</p>\n","name":"hash32","source":"/*\nTakes a seed and a string and produces a 32 bit hash.\n\nGiven the same seed and string, it will always produce the same hash.\n\nMurmur3.hash32(1234 \"Turn me into a hash\" == 4138100590)\n*/\nfun hash32 (seed : Number, str : String) : Number {\n  str\n  |> stringCodepointReduce(init, hashFold)\n  |> finalize()\n} where {\n  init =\n    {\n      shift = 0,\n      seed = seed,\n      hash = 0,\n      charsProcessed = 0\n    }\n}","arguments":[{"type":"Number","name":"seed"},{"type":"String","name":"str"}]},{"type":"Number","description":null,"name":"multiplyBy","source":"fun multiplyBy (b : Number, a : Number) : Number {\n  /* 32-bit multiplication */\n  w + z\n} where {\n  w =\n    Bitwise.and(a, 65535) * b\n\n  x =\n    Bitwise.zeroFillRightShift(16, a) * b\n\n  y =\n    Bitwise.and((x), 65535)\n\n  z =\n    Bitwise.leftShift(16, y)\n}","arguments":[{"type":"Number","name":"b"},{"type":"Number","name":"a"}]},{"type":"Number","description":null,"name":"rotlBy","source":"fun rotlBy (b : Number, a : Number) : Number {\n  /*\n   Given a 32bit int and an int representing a number of bit positions,\n  returns the 32bit int rotated left by that number of positions.\n  rotlBy : Int -> Int -> Int\n  */\n  Bitwise.or(\n    (Bitwise.leftShift(b, a)), \n    (Bitwise.zeroFillRightShift((32 - b), a)))\n}","arguments":[{"type":"Number","name":"b"},{"type":"Number","name":"a"}]},{"type":"Murmur3.HashData","description":null,"name":"hashFold","source":"fun hashFold (data : Murmur3.HashData, char : Number) : Murmur3.HashData {\n  case (data.shift) {\n    24 =>\n      {\n        shift = 0,\n        seed = mix(data.seed, res),\n        hash = 0,\n        charsProcessed = data.charsProcessed + 1\n      }\n\n    =>\n      {\n        shift = data.shift + 8,\n        seed = data.seed,\n        hash = res,\n        charsProcessed = data.charsProcessed + 1\n      }\n  }\n} where {\n  res =\n    char\n    |> Bitwise.and(255)\n    |> Bitwise.leftShift(data.shift)\n    |> Bitwise.or(data.hash)\n}","arguments":[{"type":"Murmur3.HashData","name":"data"},{"type":"Number","name":"char"}]},{"type":"Number","description":null,"name":"mix","source":"fun mix (h1 : Number, k1 : Number) : Number {\n  res + 3864292196\n} where {\n  res =\n    k1\n    |> Murmur3.multiplyBy(Murmur3:C1)\n    |> Murmur3.rotlBy(15)\n    |> multiplyBy(Murmur3:C2)\n    |> Bitwise.xor(h1)\n    |> rotlBy(13)\n    |> multiplyBy(5)\n}","arguments":[{"type":"Number","name":"h1"},{"type":"Number","name":"k1"}]},{"type":"Number","description":null,"name":"finalize","source":"fun finalize (data : Murmur3.HashData) : Number {\n  Bitwise.xor(h2, Bitwise.zeroFillRightShift(16, h2))\n  |> Bitwise.zeroFillRightShift(0)\n} where {\n  acc =\n    if (data.hash == 0) {\n      data.seed\n    } else {\n      data.hash\n      |> Murmur3.multiplyBy(Murmur3:C1)\n      |> Murmur3.rotlBy(15)\n      |> Murmur3.multiplyBy(Murmur3:C2)\n      |> Bitwise.xor(data.seed)\n    }\n\n  h0 =\n    Bitwise.xor(acc, data.charsProcessed)\n\n  h1 =\n    Bitwise.xor(h0, Bitwise.zeroFillRightShift(16, h0))\n    |> Murmur3.multiplyBy(2246822507)\n\n  h2 =\n    Bitwise.xor(h1, (Bitwise.zeroFillRightShift(13, h1)))\n    |> Murmur3.multiplyBy(3266489909)\n}","arguments":[{"type":"Murmur3.HashData","name":"data"}]},{"type":"a","description":null,"name":"stringCodepointReduce","source":"fun stringCodepointReduce (start : a, fn : Function(a, Number, a), str : String) : a {\n  res[1]\n} where {\n  res =\n    String.split(\"\", str)\n    |> Array.reduce(\n      {0, start}, \n      (acc : Tuple(Number, b), s : String) : Tuple(Number, b) {\n        if (acc[0] == 0) {\n          case (isSurrogatePair(s)) {\n            {bool, num} =>\n              if (bool) {\n                {num, acc[1]}\n              } else {\n                {0, fn(acc[1], num)}\n              }\n          }\n        } else {\n          {0, fn(acc[1], joinSurrogatePair(acc[0], s))}\n        }\n      })\n}","arguments":[{"type":"a","name":"start"},{"type":"Function(a, Number, a)","name":"fn"},{"type":"String","name":"str"}]},{"type":"Number","description":null,"name":"joinSurrogatePair","source":"fun joinSurrogatePair (l : Number, r : String) : Number {\n  (l - a) * b + c - d + e\n} where {\n  a =\n    (`0xD800` as Number)\n\n  b =\n    (`0x400` as Number)\n\n  c =\n    (`#{r}.charCodeAt(0)` as Number)\n\n  d =\n    (`0xDC00` as Number)\n\n  e =\n    (`0x10000` as Number)\n}","arguments":[{"type":"Number","name":"l"},{"type":"String","name":"r"}]},{"type":"Tuple(Bool, Number)","description":null,"name":"isSurrogatePair","source":"fun isSurrogatePair (c : String) : Tuple(Bool, Number) {\n  if ((`0xD800` as Number) <= code && code <= (`0xDBFF` as Number)) {\n    {true, code}\n  } else {\n    {false, code}\n  }\n} where {\n  code =\n    `#{c}.charCodeAt(0)` as Number\n}","arguments":[{"type":"String","name":"c"}]}]}],"providers":[],"records":[{"description":null,"name":"Murmur3.HashData","fields":[{"key":"shift","type":"Number","mapping":null},{"key":"seed","type":"Number","mapping":null},{"key":"hash","type":"Number","mapping":null},{"key":"charsProcessed","type":"Number","mapping":null}]}],"enums":[]}